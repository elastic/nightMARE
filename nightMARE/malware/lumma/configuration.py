# coding: utf-8

import dataclasses

from nightMARE.analysis import emulation
from nightMARE.analysis import reversing
from nightMARE.core import regex


C2_LIST_MAX_LENGTH = 0xFF
C2_SIZE = 0x80

CHACHA20_CTX_SIZE = 0x40
CHACHA20_INITIAL_COUNTER = 2
CHACHA20_KEY_SIZE = 0x20
CHACHA20_NONCE_SIZE = 8

CRYPTO_SETUP_PATTERN = "b838?24400b???????00b???0???0096f3a5"
DECRYPTION_FUNCTION_PATTERN = "5553575681ec1?0100008b??243?01000085??0f84??080000"
C2_DECRYPTION_BRANCH_PATTERN = "8d8?e0?244008d7424??ff3?565?68????4500e8????ffff"


@dataclasses.dataclass
class Configuration(object):
    c2: list[bytes]


def build_crypto_context(key: bytes, nonce: bytes, initial_counter: int) -> bytes:
    crypto_context = bytearray(0x40)
    crypto_context[0x10:0x30] = key
    crypto_context[0x30] = initial_counter
    crypto_context[0x38:0x40] = nonce
    return bytes(crypto_context)


def decrypt_c2_list(
    binary: bytes, encrypted_c2_list: list[bytes], key: bytes, nonce: bytes
) -> list[bytes]:
    decryption_function_address = get_decryption_function_address(binary)

    emu = emulation.WindowsEmulator(True)
    emu.load_pe(binary, 0x10000)

    chacha_ctx_address = emu.allocate_memory(CHACHA20_CTX_SIZE)
    emu.unicorn.mem_write(
        chacha_ctx_address,
        build_crypto_context(
            key,
            nonce,
            CHACHA20_INITIAL_COUNTER,
        ),
    )

    decrypted_c2_list = []
    for encrypted_c2 in encrypted_c2_list:
        encrypted_buffer_address = emu.allocate_memory(C2_SIZE)
        decrypted_buffer_address = emu.allocate_memory(C2_SIZE)
        emu.unicorn.mem_write(encrypted_buffer_address, encrypted_c2)

        emu.push(C2_SIZE)
        emu.push(decrypted_buffer_address)
        emu.push(encrypted_buffer_address)
        emu.push(chacha_ctx_address)

        emu.do_call(decryption_function_address, emu.image_base)
        emu.unicorn.emu_start(decryption_function_address, emu.image_base)

        decrypted_c2 = bytes(
            emu.unicorn.mem_read(decrypted_buffer_address, C2_SIZE)
        ).split(b"\x00")[0]

        if not regex.get_regex(regex.RegexOptions.PRINTABLE_STRING_REGEX, True).match(
            decrypted_c2
        ):
            break

        decrypted_c2_list.append(b"https://" + decrypted_c2)

        emu.pop()
        emu.pop()
        emu.pop()
        emu.pop()

        emu.free_memory(encrypted_buffer_address, C2_SIZE)
        emu.free_memory(decrypted_buffer_address, C2_SIZE)

    return decrypted_c2_list


def get_decryption_function_address(binary: bytes) -> int:
    if x := reversing.Rizin.load(binary).find_pattern(
        DECRYPTION_FUNCTION_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN
    ):
        return x[0]["address"]
    raise RuntimeError("Failed to find decryption function address")


def get_decryption_key_and_nonce(binary: bytes) -> tuple[bytes, bytes]:
    rz = reversing.Rizin.load(binary)
    if not (
        x := rz.find_pattern(
            CRYPTO_SETUP_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN
        )
    ):
        raise RuntimeError("Failed to find crypto setup pattern virtual address")

    crypto_setup_va = x[0]["address"]
    key_and_nonce_address = rz.disassemble(crypto_setup_va, 1)[0]["opex"]["operands"][
        1
    ]["value"]
    return rz.get_data(key_and_nonce_address, CHACHA20_KEY_SIZE), rz.get_data(
        key_and_nonce_address + CHACHA20_KEY_SIZE, CHACHA20_NONCE_SIZE
    )


def get_encrypted_c2_list(binary: bytes) -> list[bytes]:
    rz = reversing.Rizin.load(binary)
    address = get_encrypted_c2_list_address(binary)
    encrypted_c2 = []
    for ea in range(address, address + (C2_LIST_MAX_LENGTH * C2_SIZE), C2_SIZE):
        encrypted_c2.append(rz.get_data(ea, C2_SIZE))
    return encrypted_c2


def get_encrypted_c2_list_address(binary: bytes) -> int:
    rz = reversing.Rizin.load(binary)
    if not len(
        x := rz.find_pattern(
            C2_DECRYPTION_BRANCH_PATTERN, reversing.Rizin.PatternType.HEX_PATTERN
        )
    ):
        raise RuntimeError("Failed to find c2 decryption pattern")

    c2_decryption_va = x[0]["address"]
    return rz.disassemble(c2_decryption_va, 1)[0]["opex"]["operands"][1]["disp"]


def extract_configuration(binary: bytes) -> Configuration:
    return Configuration(
        decrypt_c2_list(
            binary, get_encrypted_c2_list(binary), *get_decryption_key_and_nonce(binary)
        )
    )
