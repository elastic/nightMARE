# coding: "utf-8"

import enum
import binascii
import ctypes
import json

from nightMARE.analysis import reversing
from nightMARE.malware.blister import crypto
from nightMARE.core import bits
from nightMARE.core.compression import lznt1


CORE_KEY_PATTERNS = [
    "FF FF D6 49 8B D7 4C 0F A3 F8 80 EC 02 C7 45 48 CD 3A 08 08",
    "48 8D 55 F0 48 83 C9 FF FF D6 49 8B D7 C7 45 48 ?? ?? ?? ?? ?? 8B ??",
]

CORE_TAG_PATTERNS = [
    "8B 7D 38 B8 ?? ?? ?? ?? E9 70",
    "8B 7D ?? B8 ?? ?? ?? ?? EB 0F 41 ?? B7 ?? 8B 34 87 ?? 03 ?? EB ??",
]

CONFIG_TAG_PATTERNS = [
    "48 89 04 24 49 63 C4 48 8B 04 24 F9 41 80 F8 F3 F5 81 38 ?? ?? ?? ?? E9 00 00 00 00"
]

CORE_TAG_OFFSET = 4
CONFIG_TAG_OFFSET = 19
TAG_SIZE = 4

KEY_OFFSET = 16
KEY_SIZE = 4

CORE_OFFSET = 4
CONFIG_SIZE = 0x66B


class SignatureNotFoundError(Exception):
    pass


class RawConfiguration(ctypes.Structure):
    _pack_ = 1
    _fields_ = [
        ("config_offset", ctypes.c_uint32),
        ("flag", ctypes.c_uint32),
        ("domain_hash", ctypes.c_uint32),
        ("payload_export_hash", ctypes.c_uint32),
        ("sleep_time", ctypes.c_uint32),
        ("unk_0", ctypes.c_uint8 * 1566),
        ("compressed_data_size", ctypes.c_uint32),
        ("uncompressed_data_size", ctypes.c_uint32),
        ("rabbit_iv", ctypes.c_uint8 * 8),
        ("rabbit_key", ctypes.c_uint8 * 16),
    ]


class Configuration(object):
    """
    Represents Blister configuration object.

    Attributes:
        flag (int): A set of flags indicating various settings for the Blister.
        domain_hash (int): Hash value associated with the domain for the keying feature.
        payload_export_hash (int): Hash value associated with payload export.
        sleep_time (int): Time in seconds for sleep intervals.
        rabbit_key (bytes): Encryption key for Rabbit algorithm.
        rabbit_iv (bytes): Initialization vector for Rabbit algorithm.
        compressed_data_size (int): Size of compressed payload.
        uncompressed_data_size (int): Size of uncompressed payload.
        payload (bytes): Extracted payload .

    Note:
        The is_pe attribute is set to True based on the presence of the
        Configuration.Flags.EXECUTE_SHELLCODE_METHOD flag in the flag attribute.
    """

    class Flags(enum.Enum):
        DO_PERSISTANCE = 0x1
        OWN_PROCESS_REFLECTIVE_INJECTION_METHOD = 0x2
        OWN_PROCESS_HOLLOWING_METHOD = 0x8
        REMOTE_PROCESS_HOLLOWING_METHOD = 0x10
        EXECUTE_PAYLOAD_EXPORT = 0x20
        EXECUTE_SHELLCODE_METHOD = 0x40
        INJECT_WITH_CMDLINE = 0x80
        USE_SYSCALLS = 0x100
        USE_FRESH_MAPPED_NTDLL = 0x200
        ENABLE_SLEEP_BEFORE_INJECTION = 0x1000
        CUSTOM_SLEEP_TIMER_SET = 0x2000
        ENABLE_PROCESS_INSTRUMENTATION_UNHOOK = 0x80000
        ENABLE_KEYING = 0x100000

    def __init__(
        self,
        flag: int,
        domain_hash: int,
        payload_export_hash: int,
        sleep_time: int,
        rabbit_key: bytes,
        rabbit_iv: bytes,
        compressed_data_size: int,
        uncompressed_data_size: int,
        payload: bytes,
    ):
        self.flag = flag
        self.domain_hash = domain_hash
        self.payload_export_hash = payload_export_hash
        self.sleep_time = (
            sleep_time
            if Configuration.Flags.CUSTOM_SLEEP_TIMER_SET.value & self.flag
            else 600000
        )
        self.rabbit_key = rabbit_key
        self.rabbit_iv = rabbit_iv
        self.compressed_data_size = compressed_data_size
        self.uncompressed_data_size = uncompressed_data_size
        self.is_pe = not Configuration.Flags.EXECUTE_SHELLCODE_METHOD.value & self.flag
        self.payload = b"MZ" + payload[2:] if self.is_pe else payload

    @property
    def __injection_method(self) -> str:
        if (
            Configuration.Flags.OWN_PROCESS_REFLECTIVE_INJECTION_METHOD.value
            & self.flag
        ):
            return "Reflective injection"
        elif Configuration.Flags.EXECUTE_SHELLCODE_METHOD.value & self.flag:
            return "Execute shellcode"
        elif Configuration.Flags.OWN_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing current executable (rundll32.exe in case of a DLL sample)"
        elif Configuration.Flags.REMOTE_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing IE or Werfault"
        else:
            raise RuntimeError("Injection method missing in configuration")

    @property
    def enabled_features(self) -> list[str]:
        return [x.name for x in Configuration.Flags if x.value & self.flag]

    @staticmethod
    def from_raw(raw_configuration: RawConfiguration, payload: bytes):
        return Configuration(
            raw_configuration.flag,
            raw_configuration.domain_hash,
            raw_configuration.payload_export_hash,
            raw_configuration.sleep_time,
            bytes(raw_configuration.rabbit_key),
            bytes(raw_configuration.rabbit_iv),
            raw_configuration.compressed_data_size,
            raw_configuration.uncompressed_data_size,
            payload,
        )

    def __repr__(self) -> str:
        return json.dumps(
            {
                "Configuration": {
                    "flag": hex(self.flag),
                    "domain_keying_hash": hex(self.domain_hash),
                    "payload_export_hash": hex(self.payload_export_hash),
                    "sleep_time": self.sleep_time,
                    "rabbit_key": binascii.hexlify(self.rabbit_key).decode(),
                    "rabbit_iv": binascii.hexlify(self.rabbit_iv).decode(),
                    "compressed_data_size": hex(self.compressed_data_size),
                    "uncompressed_data_size": hex(self.uncompressed_data_size),
                    "injection_method": self.__injection_method,
                    "is_pe": self.is_pe,
                    "enabled_features": self.enabled_features,
                }
            },
            indent=4,
        )


def extract_configuration(binary: bytes) -> RawConfiguration:
    """
    Extracts configuration data from Blister sample using the provided BlisterHelper instance.

    :param data: bytes of a Blister sample to extract the configuration and payload
    :return: Extracted configuration data from the Blister sample.
    """
    raw_configuration = get_raw_configuration(get_core_blob(binary))
    return Configuration.from_raw(
        raw_configuration, get_payload(binary, raw_configuration)
    )


def get_config_tag(core_blob: bytes) -> bytes:
    return reversing.Radare2.load(core_blob).get_data(
        get_pattern_address(core_blob, CONFIG_TAG_PATTERNS) + CONFIG_TAG_OFFSET,
        TAG_SIZE,
    )


def get_core_blob(binary: bytes) -> bytes:
    """
    Decrypts the Blister's core using provided data and returns a BlisterHelper instance.

    :param data: The PE content.
    :return: A BlisterHelper instance after decrypting the Blister's core using provided data.

    """
    return bits.xor(
        get_rsrc_section(binary)[get_core_offset(binary) :],
        get_core_key(binary),
    )


def get_core_key(binary: bytes) -> bytes:
    return reversing.Radare2.load(binary).get_data(
        get_pattern_address(binary, CORE_KEY_PATTERNS) + KEY_OFFSET, KEY_SIZE
    )


def get_core_offset(binary: bytes) -> int:
    return get_rsrc_section(binary).find(get_core_tag(binary)) + TAG_SIZE


def get_core_tag(binary: bytes) -> bytes:
    tag_address = get_pattern_address(binary, CORE_TAG_PATTERNS)
    return reversing.Radare2.load(binary).get_data(
        tag_address + CORE_TAG_OFFSET, TAG_SIZE
    )


def get_payload(binary: bytes, raw_configuration: RawConfiguration) -> bytes:
    offset = get_core_offset(binary) + raw_configuration.config_offset + CONFIG_SIZE
    cipher = crypto.Rabbit(
        bytes(raw_configuration.rabbit_key), bytes(raw_configuration.rabbit_iv)
    )
    return lznt1.decompress(
        cipher.crypt(
            get_rsrc_section(binary)[
                offset : offset + raw_configuration.compressed_data_size
            ]
        )
    )


def get_pattern_address(binary: bytes, patterns: list[str]) -> int:
    """
    Searches for the first occurrence of any of the provided patterns within the disassembled data.

    :param r2: An instance of Radare2 disassembler used to search for patterns.
    :param patterns: A list of hex patterns (as strings) to search for in the disassembled data.

    :return: The offset (integer) of the first matching pattern found in the disassembled data.

    :raises SignatureNotFoundException: If none of the provided patterns are found.
    """
    for x in patterns:
        if result := reversing.Radare2.load(binary).find_pattern(
            x, reversing.Radare2.PatternType.HEX_PATTERN
        ):
            return result[0]["offset"]
    else:
        raise SignatureNotFoundError()


def get_raw_configuration(core_blob: bytes) -> RawConfiguration:
    if -1 == (config_blob_offset := core_blob.rfind(get_config_tag(core_blob))):
        raise SignatureNotFoundError()
    config_blob_offset += TAG_SIZE

    return RawConfiguration.from_buffer_copy(
        config_blob_offset.to_bytes(4, "little") + core_blob[config_blob_offset:]
    )


def get_rsrc_section(binary: bytes) -> bytes:
    return reversing.Radare2.load(binary).get_section(".rsrc")
