# coding: utf-8

from __future__ import annotations

import pathlib
import lief

from Crypto.Cipher import ARC4

from nightMARE.core import cast
from nightMARE.analysis import reversing

from nightMARE.malware.remcos import struct

KEY_SIZE_OFFSET = 0
KEY_OFFSET = 1


def get_encrypted_configuration(binary: bytes) -> bytes:
    """
    Read the encrypted configuration from the given file path.

    :param path: The path to the configuration file.
    :return: The encrypted configuration as bytes, or None if the file cannot be parsed or the configuration is not found.
    """
    pe = lief.parse(binary)
    for first_level_child in pe.resources.childs:
        if first_level_child.id != 10:
            continue

        for second_level_child in first_level_child.childs:
            if second_level_child.name == "SETTINGS":
                return bytes(second_level_child.childs[0].content)
    else:
        raise RuntimeError("Failed to get encryptede configuration")


def patch_encrypted_configuration(
    path: pathlib.Path, encrypted_configuration: bytes
) -> None:
    """
    Patch the encrypted configuration in the specified PE file.

    :param path: The path to the PE file.
    :param encrypted_configuration: The encrypted configuration to patch the PE with.
    """
    pe = lief.parse(path)
    for first_level_child in pe.resources.childs:
        if first_level_child.id != 10:
            continue

        for second_level_child in first_level_child.childs:
            if second_level_child.name == "SETTINGS":
                second_level_child.delete_child(0)
                second_level_child.add_data_node(
                    lief.PE.ResourceData(list(encrypted_configuration), 0)
                )

                builder = lief.PE.Builder(pe)
                builder.build_resources(True)
                builder.build()
                builder.write(str(path))
                return


def get_raw_configuration(binary: bytes) -> bytes:
    """
    Decrypts the encrypted configuration.

    :param encrypted_configuration: The encrypted configuration to be decrypted.
    :return: A tuple containing the decrypted key and the decrypted configuration.
    """
    r2 = reversing.Radare2(get_encrypted_configuration(binary))
    key_size = r2.get_u8(KEY_SIZE_OFFSET)
    key = r2.get_data(KEY_OFFSET, key_size)
    return ARC4.ARC4Cipher(key).decrypt(r2.get_data(KEY_OFFSET + key_size))


def encrypt_configuration(configuration: bytes, key: bytes) -> bytes:
    """
    Encrypts the given configuration using the provided key.

    :param configuration: The configuration to be encrypted.
    :param key: The encryption key.
    :return: The encrypted configuration.
    """
    return cast.p8(len(key)) + key + ARC4.ARC4Cipher(key).encrypt(configuration)


def extract_configuration(binary: bytes) -> bytes:
    return struct.unpack_configuration(get_raw_configuration(binary))
