# coding: utf-8

import re
import json

from nightMARE.analysis import reversing
from nightMARE.core import common_regex

from nightMARE.malware.lobshot import crypto

DECRYPTION_FUNCTION_PATTERN = "8A 5A ?? 8D 52 ?? 80 EB ?? 85 FF 74 ?? C0 E0 ?? 2C ?? 0A C3 32 C1 32 C7 88 06 32 E8 83 C6 ?? 83 C5 ?? EB ??"


class Configuration(object):
    def __init__(self, ip: str, port: int):
        self.ip = ip
        self.port = port

    def __repr__(self) -> str:
        return json.dumps({"ip": str(self.ip, "utf-8"), "port": self.port}, indent=4)


def get_decryption_function_pattern_offset(binary: bytes) -> int:
    r2 = reversing.Radare2.load(binary)
    return r2.find_pattern(
        DECRYPTION_FUNCTION_PATTERN, reversing.Radare2.PatternType.HEX_PATTERN
    )[0]["offset"]


def get_encrypted_strings(binary) -> list[bytes]:
    r2 = reversing.Radare2.load(binary)

    result = []
    ea = get_encrypted_string_table(binary)
    while True:
        s = r2.get_strings(r2.get_u32(ea))
        if not is_string_valid(s):
            break
        result.append(s)
        ea += 4

    return result


def get_encrypted_string_table(binary: bytes) -> list[bytes]:
    pattern_offset = get_decryption_function_pattern_offset(binary)

    r2 = reversing.Radare2.load(binary)
    target_register = r2.disassemble(pattern_offset, 1)[0]["opex"]["operands"][1][
        "base"
    ]

    ea = pattern_offset
    while ea >= r2.get_function_start_offset(pattern_offset):
        prev_insn = r2.disassemble_previous_instruction(ea)
        ea = prev_insn["addr"]

        if 2 != len(prev_insn["opex"]["operands"]):
            continue

        first_op = prev_insn["opex"]["operands"][0]
        second_op = prev_insn["opex"]["operands"][1]
        if (
            first_op["type"] == "reg"
            and first_op["value"] == target_register
            and second_op["type"] == "mem"
        ):
            return second_op["disp"]
    else:
        raise RuntimeError("Encrypted string table not found")


def get_strings(binary) -> list[bytes]:
    return list(map(crypto.decrypt_string, get_encrypted_strings(binary)))


def is_string_valid(s: bytes) -> bool:
    return all(map(lambda x: 0x61 <= x <= 0x7A, s))


def extract_configuration(binary: bytes) -> Configuration:
    """
    The function will search the configuration ip and port within the data blob
    :param: Data blob containing encrypted ip and port strings
    :return: Configuration ip and optionally port
    """
    ip = None
    port = None
    for x in get_strings(binary):
        print(x)
        if ip and port:
            return Configuration(ip, port)

        if re.search(common_regex.IP_ADDRESS_REGEX, x):
            ip = x
        if re.search(common_regex.PORT_REGEX, x):
            port = int(x)

    else:
        raise RuntimeError("Failed to extract IP/Port")
