# coding: utf-8

import typing

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing

RC4_DECRYPTION_PATTERNS = [
    "02 ?? 0F B6 C9 88 ?? ?? ?? 0F B6 ?? ?? ?? 30 0C ?? 47",
    "01 ?? 0F B6 C9 8A ?? ?? ?? 30 0C ?? 47",
]

RC4_INIT_PATTERNS = [
    "0F B6 ?? 8A ?? ?? ?? 88 ?? ?? 89 ?? 88 ?? ?? ?? 8D ?? ?? 99 F7 7C ?? ??",
    "0F B6 ?? 8A ?? ?? ?? 88 ?? ?? 8D ?? ?? 88 ?? ?? ?? 99 F7 7C ?? ??",
]

NULL_BYTE = b"\x00"


def parse_and_set_config(config: list) -> dict[str, typing.Any]:
    netwire_config = dict()
    try:
        domain_list = config[0].rstrip(";").split(";")
        netwire_config["c2_list"] = domain_list
        netwire_config["password"] = config[2]
        netwire_config["host_id"] = config[3]
        netwire_config["mutex"] = config[4]
        netwire_config["installation_path"] = config[5]
        netwire_config["run_registry_key_entry"] = config[6]
        netwire_config["active_setup_Key"] = config[7]
        netwire_config["keylogger_logs_directory"] = config[8]
        netwire_config["sleep_in_seconds"] = int(config[11])
    except (IndexError, ValueError):
        raise RuntimeError(
            "Unable to extract the configuration: Unable the parse the configuration"
        )
    return netwire_config


def decrypt_configuration(
    binary: bytes, RC4_key_offset: list, encrypted_strings_offsets: list
):
    r2 = reversing.Radare2.load(binary)
    config = []
    RC4_key = r2.get_data(RC4_key_offset[0], RC4_key_offset[1])
    for i in range(len(encrypted_strings_offsets)):
        decrypted_data = ARC4.new(RC4_key).decrypt(
            r2.get_data(
                encrypted_strings_offsets[i][0], encrypted_strings_offsets[i][1]
            )
        )
        if NULL_BYTE in decrypted_data:
            decrypted_data = decrypted_data[: decrypted_data.index(NULL_BYTE)]

        config.append(decrypted_data.decode("utf-8"))

    return parse_and_set_config(config)


def get_function_args(binary: bytes, reference_to_func: int) -> list:
    r2 = reversing.Radare2.load(binary)
    ea = reference_to_func
    data_offset_and_size = []
    for _ in range(4):
        prev_insn = r2.disassemble_previous_instruction(ea)[0]

        if len(prev_insn["opex"]["operands"]) > 1:
            if prev_insn["mnemonic"] == "mov":
                first_op = prev_insn["opex"]["operands"][0]
                second_op = prev_insn["opex"]["operands"][1]
                if first_op["type"] == "mem" and second_op["type"] == "imm":
                    data_offset_and_size.append(second_op["value"])

        if prev_insn["mnemonic"] == "push":
            first_op = prev_insn["opex"]["operands"][0]
            if first_op["type"] == "imm":
                data_offset_and_size.append(first_op["value"])

        ea = prev_insn["addr"]

        if len(data_offset_and_size) == 2:
            return data_offset_and_size

    else:
        raise RuntimeError("Unable to retrieve arguments from function")


def get_RC4_init_args(binary: bytes, reference_to_rc4_init_func: int) -> list:
    return get_function_args(binary, reference_to_rc4_init_func)


def get_RC4_init_function_offset(binary: bytes) -> int:
    r2 = reversing.Radare2.load(binary)
    offset = None
    for pattern in RC4_INIT_PATTERNS:
        if offset := r2.find_pattern(
            pattern, reversing.Radare2.PatternType.HEX_PATTERN
        ):
            return r2.get_function_start_offset(offset[0]["offset"])
    else:
        raise RuntimeError("Unable to find pattern for the RC4 init function")


def get_RC4_key_offset(binary: bytes) -> list:
    """
    Returns a list containing the offset to the RC4 key and its size
    """
    r2 = reversing.Radare2.load(binary)
    rc4_init_func_start = get_RC4_init_function_offset(binary)
    references_to_rc4_init_func = r2.get_references_to(rc4_init_func_start)
    return get_RC4_init_args(binary, references_to_rc4_init_func[0])


def get_decrypt_function_offset(binary: bytes) -> int:
    r2 = reversing.Radare2.load(binary)
    offset = None
    for pattern in RC4_DECRYPTION_PATTERNS:
        if offset := r2.find_pattern(
            pattern, reversing.Radare2.PatternType.HEX_PATTERN
        ):
            return r2.get_function_start_offset(offset[0]["offset"])
    else:
        raise RuntimeError("Unable to find pattern for the RC4 init function")


def get_decryption_args(binary: bytes, references_to_decrypt_func: list) -> list:
    data_offsets_and_sizes = []
    for i in range(len(references_to_decrypt_func)):
        data_offsets_and_sizes.append(
            get_function_args(binary, references_to_decrypt_func[i])
        )
    return data_offsets_and_sizes


def get_encrypted_strings_offsets(binary: bytes) -> list:
    """
    Returns a list containing lists of the offsets to encrypted strings and their sizes
    """
    r2 = reversing.Radare2.load(binary)
    decrypt_func_start = get_decrypt_function_offset(binary)
    references_to_decrypt_func = r2.get_references_to(decrypt_func_start)

    if len(references_to_decrypt_func) == 1:
        references_to_decrypt_func = r2.get_references_to(
            r2.get_function_start_offset(references_to_decrypt_func[0])
        )

    return get_decryption_args(binary, references_to_decrypt_func)


def extract_configuration(binary: bytes) -> dict[str, typing.Any]:
    RC4_key_offset = get_RC4_key_offset(binary)
    encrypted_strings_offsets = get_encrypted_strings_offsets(binary)
    return decrypt_configuration(binary, RC4_key_offset, encrypted_strings_offsets)
