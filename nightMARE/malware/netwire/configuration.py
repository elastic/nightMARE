# coding: utf-8

import typing
import json

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing

RC4_DECRYPTION_PATTERNS = [
    "02 ?? 0F B6 C9 88 ?? ?? ?? 0F B6 ?? ?? ?? 30 0C ?? 47",
    "01 ?? 0F B6 C9 8A ?? ?? ?? 30 0C ?? 47",
]

RC4_INIT_PATTERNS = [
    "0F B6 ?? 8A ?? ?? ?? 88 ?? ?? 89 ?? 88 ?? ?? ?? 8D ?? ?? 99 F7 7C ?? ??",
    "0F B6 ?? 8A ?? ?? ?? 88 ?? ?? 8D ?? ?? 88 ?? ?? ?? 99 F7 7C ?? ??",
]


class Configuration(object):
    def __init__(self, config: list):
        self.c2_list: list[bytes] = config[0].rstrip(b";").split(b";")
        self.password: bytes = config[2]
        self.host_id: bytes = config[3]
        self.mutex: bytes = config[4]
        self.installation_path: bytes = config[5]
        self.run_registry_key_entry: bytes = config[6]
        self.active_setup_key: bytes = config[7]
        self.keylogger_logs_directory: bytes = config[8]
        self.sleep_in_seconds = int(config[11])

    def __repr__(self) -> str:
        return json.dumps(
            {
                "c2_list": [x.decode("utf-8") for x in self.c2_list],
                "password": self.password.decode("utf-8"),
                "host_id": self.host_id.decode("utf-8"),
                "mutex": self.mutex.decode("utf-8"),
                "installation_path": self.installation_path.decode("utf-8"),
                "run_registry_key_entry": self.run_registry_key_entry.decode("utf-8"),
                "active_setup_key": self.active_setup_key.decode("utf-8"),
                "keylogger_logs_directory": self.keylogger_logs_directory.decode(
                    "utf-8"
                ),
                "sleep_in_seconds": self.sleep_in_seconds,
            }
        )


def get_encrypted_strings(binary: bytes) -> list[bytes]:
    r2 = reversing.Radare2.load(binary)
    return [
        r2.get_data(x[0], x[1]) for x in get_encrypted_strings_offsets_and_sizes(binary)
    ]


def decrypt_configuration(binary: bytes, key: bytes) -> Configuration:
    raw_config = []
    for x in get_encrypted_strings(binary):
        decrypted_data = ARC4.new(key).decrypt(x)
        raw_config.append(decrypted_data.split(b"\x00")[0])
    return Configuration(raw_config)


def get_function_data_offset_and_size_args(
    binary: bytes, reference_to_func: int
) -> tuple[int, int]:
    r2 = reversing.Radare2.load(binary)

    ea = reference_to_func
    data_offset_and_size = []
    for _ in range(4):
        prev_insn = r2.disassemble_previous_instruction(ea)

        if len(prev_insn["opex"]["operands"]) > 1:
            if prev_insn["mnemonic"] == "mov":
                first_op = prev_insn["opex"]["operands"][0]
                second_op = prev_insn["opex"]["operands"][1]
                if first_op["type"] == "mem" and second_op["type"] == "imm":
                    data_offset_and_size.append(second_op["value"])

        elif prev_insn["mnemonic"] == "push":
            first_op = prev_insn["opex"]["operands"][0]
            if first_op["type"] == "imm":
                data_offset_and_size.append(first_op["value"])

        ea = prev_insn["addr"]

        if len(data_offset_and_size) == 2:
            return tuple(data_offset_and_size)

    else:
        raise RuntimeError("Unable to retrieve arguments from function")


def get_rc4_init_function_offset(binary: bytes) -> int:
    r2 = reversing.Radare2.load(binary)
    offset = None
    for pattern in RC4_INIT_PATTERNS:
        if offset := r2.find_pattern(
            pattern, reversing.Radare2.PatternType.HEX_PATTERN
        ):
            return r2.get_function_start_offset(offset[0]["offset"])
    else:
        raise RuntimeError("Unable to find pattern for the RC4 init function")


def get_rc4_key_offset_and_size(binary: bytes) -> tuple[int, int]:
    """
    Returns a list containing the offset to the RC4 key and its size
    """
    r2 = reversing.Radare2.load(binary)
    return get_function_data_offset_and_size_args(
        binary, r2.get_xrefs_to(get_rc4_init_function_offset(binary))[0]
    )


def get_decrypt_function_offset(binary: bytes) -> int:
    r2 = reversing.Radare2.load(binary)
    offset = None
    for pattern in RC4_DECRYPTION_PATTERNS:
        if offset := r2.find_pattern(
            pattern, reversing.Radare2.PatternType.HEX_PATTERN
        ):
            return r2.get_function_start_offset(offset[0]["offset"])
    else:
        raise RuntimeError("Unable to find pattern for the RC4 init function")


def get_decryption_args(binary: bytes, references_to_decrypt_func: list) -> list:
    data_offsets_and_sizes = []
    for i in range(len(references_to_decrypt_func)):
        data_offsets_and_sizes.append(
            get_function_data_offset_and_size_args(
                binary, references_to_decrypt_func[i]
            )
        )
    return data_offsets_and_sizes


def get_encrypted_strings_offsets_and_sizes(binary: bytes) -> list:
    """
    Returns a list containing lists of the offsets to encrypted strings and their sizes
    """
    r2 = reversing.Radare2.load(binary)

    references_to_decrypt_func = r2.get_xrefs_to(get_decrypt_function_offset(binary))
    if len(references_to_decrypt_func) == 1:
        references_to_decrypt_func = r2.get_xrefs_to(
            r2.get_function_start_offset(references_to_decrypt_func[0])
        )

    return get_decryption_args(binary, references_to_decrypt_func)


def get_rc4_key(binary: bytes) -> bytes:
    return reversing.Radare2.load(binary).get_data(*get_rc4_key_offset_and_size(binary))


def extract_configuration(binary: bytes) -> dict[str, typing.Any]:
    return decrypt_configuration(
        binary,
        get_rc4_key(binary),
    )
