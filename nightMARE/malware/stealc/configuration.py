# coding: "utf-8"

import base64
import re
import typing
import json

from nightMARE.malware.stealc import crypto
from nightMARE.core import utils
from nightMARE.analysis import reversing


KEY_REGEX = re.compile(b"[0-9]{28}")
URI_TLD_REGEX = re.compile(b"/\\b[\\w.-]+\\.[a-zA-Z]{2,}\\b")


class Configuration(object):
    def __init__(self, c2: bytes, key: bytes):
        self.c2 = c2
        self.key = key

    def __repr__(self) -> str:
        return json.dumps(
            {"c2": self.c2.decode("utf-8"), "key": self.key.decode("utf-8")}
        )


def get_decrypted_strings(key: bytes, candidate_strings: list[bytes]) -> list[bytes]:
    decrypted_strings = [
        crypto.decrypt_string(base64.b64decode(x), key)
        for x in filter(utils.is_base64, candidate_strings)
    ]

    if not decrypted_strings:
        raise RuntimeError("Failed to decrypt strings")

    return decrypted_strings


def get_key(candidate_strings: list[bytes]) -> bytes:
    for string in candidate_strings:
        if match := re.search(KEY_REGEX, string):
            return match.group(0)
    else:
        raise RuntimeError("Failed to find key")


def get_candidate_strings(binary: bytes) -> list[bytes]:
    r2 = reversing.Radare2.load(binary)
    candidate_strings = [
        entry["string"].encode("utf-8")
        for entry in r2.get_strings_info_data_sections()
        if entry.get("type") == "ascii"
    ]

    if not candidate_strings:
        raise RuntimeError("Failed to find ASCII strings in data section")

    return candidate_strings


def get_c2(decrypted_strings: list[bytes]) -> bytes:
    url = None
    uri = b""
    for string in decrypted_strings:
        if url is None and utils.is_url(string):
            url = string
        elif match := re.search(URI_TLD_REGEX, string):
            uri = match.group(0)
            if url:
                break

    if url is None:
        raise RuntimeError("Failed to find URL string")

    return url + uri


def extract_configuration(binary: bytes) -> Configuration:
    candidate_strings = get_candidate_strings(binary)
    key = get_key(candidate_strings)
    return Configuration(get_c2(get_decrypted_strings(key, candidate_strings)), key)
