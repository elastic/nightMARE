# coding: utf-8

import base64
import json
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Cipher import AES
from Crypto.Hash import SHA1
from Crypto.Util.Padding import unpad

from nightMARE.analysis import reversing

from dnlib.DotNet import ModuleDefMD  # type: ignore
from dnlib.DotNet.Emit import OpCodes  # type: ignore


class Configuration(object):

    def __init__(self, config: dict):
        """
        Initialize the Configuration object with a dictionary of decrypted configuration strings.

        :param config: A dictionary of field name and decrypted value pairs
        """
        self.hosts: list[str] = (
            config.get("Hosts", "").split(",") if config.get("Hosts") else []
        )
        self.ports: list[str] = (
            config.get("Ports", "").split(",") if config.get("Ports") else []
        )
        self.version = config.get("Version", "")
        self.install = config.get("Install", "")
        self.install_folder = config.get("InstallFolder", "")
        self.install_file = config.get("InstallFile", "")
        self.key = config.get("Key", "")
        self.mutex = config.get("MTX", "")
        self.certificate = config.get("Certificate", "")
        self.server_signature = config.get("Serversignature", "")
        self.anti = config.get("Anti", "")
        self.pastebin = config.get("Pastebin", "")
        self.bdos = config.get("BDOS", "")
        self.delay = config.get("Delay", "")
        self.group = config.get("Group", "")

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded configuration fields.
        """
        return json.dumps(
            {
                "hosts": self.hosts,
                "ports": self.ports,
                "version": self.version,
                "install": self.install,
                "install_folder": self.install_folder,
                "install_file": self.install_file,
                "key": self.key,
                "mutex": self.mutex,
                "certificate": self.certificate,
                "server_signature": self.server_signature,
                "anti": self.anti,
                "pastebin": self.pastebin,
                "bdos": self.bdos,
                "delay": self.delay,
                "group": self.group,
            },
            indent=4,
        )


class Aes:
    def __init__(self, master_key: bytes | str, salt: bytes | str):
        """
        Initialize an AES context with a key derived from a master key and salt using PBKDF2.

        :param master_key: The master key for key derivation.
        :param salt: The salt for key derivation.
        """
        derived = PBKDF2(
            master_key, salt, dkLen=32 + 64, count=50000, hmac_hash_module=SHA1
        )
        self.aes_key = derived[:32]

    def decrypt(self, input_b64: str) -> str:
        """
        Decrypt a base64-encoded string using AES-256-CBC and return the plaintext as a UTF-8 string.

        :param input_b64: Base64-encoded string containing HMAC, IV, and ciphertext.
        :return: Decrypted plaintext as a UTF-8 string.
        """
        input_bytes = base64.b64decode(input_b64)
        decrypted_bytes = self._decrypt_bytes(input_bytes)
        return decrypted_bytes.decode("utf-8")

    def _decrypt_bytes(self, input: bytes) -> bytes:
        """
        Decrypt raw bytes containing HMAC, IV, and ciphertext using AES-256-CBC.

        :param input: Bytes containing HMAC (32 bytes), IV (16 bytes), and ciphertext.
        :return: Decrypted plaintext bytes after removing PKCS7 padding.
        """
        if len(input) < 48:
            raise ValueError("AES: Input too short")

        iv = input[32:48]
        ciphertext = input[48:]

        cipher = AES.new(self.aes_key, AES.MODE_CBC, iv=iv)
        padded_data = cipher.decrypt(ciphertext)

        try:
            return unpad(padded_data, AES.block_size, style="pkcs7")
        except ValueError as e:
            raise ValueError("AES: Invalid padding: %s" % e)


def get_encrypted_config(module: ModuleDefMD) -> dict:
    """
    Extract encrypted configuration (field name and value) from the Client.Settings class.

    This function searches for the .cctor method in Client.Setting and collects field
    assignments (Stsfld) preceded by string loads (Ldstr).

    :param module: The .NET module to analyze.
    :return: A dictionary mapping field names to their encrypted string values.
    """
    settings_type = reversing.Dnlib.find_type_by_name(module, "Client.Settings")

    if not settings_type:
        raise RuntimeError("Failed to find Client.Settings class")

    cctor_method = reversing.Dnlib.find_methods_by_name(module, ".cctor", settings_type)

    if len(cctor_method) == 0:
        raise RuntimeError("Failed to find .cctor method in Client.Settings class")

    encrypted_config = {}

    instructions = reversing.Dnlib.get_instructions_of_method(cctor_method[0])
    prev_opcode = None
    prev_operand = None
    for offset, (opcode, operand) in instructions.items():
        if prev_opcode and prev_opcode == OpCodes.Ldstr and opcode == OpCodes.Stsfld:
            encrypted_config[operand.Name.String] = prev_operand
        prev_opcode = opcode
        prev_operand = operand

    return encrypted_config


def get_salt(module: ModuleDefMD) -> bytes | str:
    """
    Retrieve the AES salt from the Client.Algorithm.Aes256 class.

    This function searches for the .cctor method in Client.Algorithm.Aes256 and extracts
    the salt from either an Ldtoken (byte array) or Ldstr (string) instruction.

    :param module: The .NET module to analyze.
    :return: The salt.
    """
    algorithm_type = reversing.Dnlib.find_type_by_name(
        module, "Client.Algorithm.Aes256"
    )

    if not algorithm_type:
        raise RuntimeError("Failed to find Client.Algorithm.Aes256 class")

    cctor_method = reversing.Dnlib.find_methods_by_name(
        module, ".cctor", algorithm_type
    )

    if len(cctor_method) == 0:
        raise RuntimeError(
            "Failed to find .cctor method in Client.Algorithm.Aes256 class"
        )

    salt_bytearray = None
    instructions = reversing.Dnlib.get_instructions_of_method(cctor_method[0])
    for offset, (opcode, operand) in instructions.items():
        if opcode == OpCodes.Ldtoken:
            salt_bytearray = operand.InitialValue
            return bytes(salt_bytearray)
        elif opcode == OpCodes.Ldstr:
            salt = operand
            return salt

    raise RuntimeError("Failed to find salt in Aes256 .cctor")


def decrypt_configuration(encrypted_config: dict, aes_ctx: Aes) -> dict:
    """
    Decrypt an encrypted configuration dictionary using the provided AES context.

    This function attempts to decrypt each field value in the encrypted configuration.
    If decryption fails, it assigns an empty string or the original value.

    :param encrypted_config: Dictionary with field names and encrypted values.
    :param aes_ctx: AES context for decryption.
    """
    decrypted_config = {}
    for field, value in encrypted_config.items():
        try:
            decrypted_config[field] = aes_ctx.decrypt(value)
        except Exception as e:
            decrypted_config[field] = "" if not value else value

    return decrypted_config


def extract_configuration(binary: bytes) -> Configuration:
    """
    Exctracts the configuration from a AsyncRAT sample, returning a Configuration object.

    :param binary: The .NET binary as bytes.
    :return: A Configuration object containing decrypted configuration.
    """
    module = reversing.Dnlib.load(binary)
    encrypted_config = get_encrypted_config(module)
    salt = get_salt(module)
    aes_ctx = Aes(base64.b64decode(encrypted_config["Key"]), salt)
    decrypted_config = decrypt_configuration(encrypted_config, aes_ctx)

    return Configuration(decrypted_config)
