# coding: utf-8

import base64
import json
from Crypto.Cipher import AES
import hashlib

from nightMARE.analysis import reversing

from dnlib.DotNet import ModuleDefMD  # type: ignore
from dnlib.DotNet.Emit import OpCodes  # type: ignore


class Configuration(object):

    def __init__(self, config: dict):
        """
        Initialize the Configuration object with a dictionary of decrypted configuration strings.

        :param config: A dictionary of field name and decrypted value pairs
        """
        self.hosts: list[str] = (
            config.get("Hosts", "").split(",") if config.get("Hosts") else []
        )
        self.port = config.get("Port", "")
        self.key = config.get("KEY", "")
        self.spl = config.get("SPL", "")
        self.sleep = config.get("Sleep", "")
        self.group = config.get("Groub", "")
        self.usbnm = config.get("USBNM", "")
        self.mutex = config.get("Mutex", "")
        self.install_dir = config.get("InstallDir", "")
        self.install_str = config.get("InstallStr", "")

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded configuration fields.
        """
        return json.dumps(
            {
                "hosts": self.hosts,
                "port": self.port,
                "key": self.key,
                "spl": self.spl,
                "sleep": self.sleep,
                "group": self.group,
                "usbnm": self.usbnm,
                "mutex": self.mutex,
                "install_dir": self.install_dir,
                "install_str": self.install_str,
            },
            indent=4,
        )


class Aes:
    def __init__(self, mutex: str):
        """
        Initialize an AES context using a key derived from the MD5 hash of a mutex string.

        The mutex is hashed with MD5, and the resulting 16-byte digest is used to create a
        32-byte AES-256 key by duplicating the first 16 bytes.

        :param mutex: The mutex string used for key derivation.
        """
        self.mutex = mutex.encode()
        md5 = hashlib.md5(self.mutex)
        mutex_hash = md5.digest()

        key = bytearray(32)
        key[:16] = mutex_hash[:16]
        key[15:31] = mutex_hash[:16]
        self.aes_ctx = AES.new(key, AES.MODE_ECB)

    def decrypt(self, input_b64: str) -> str:
        """
        Decrypt a base64-encoded string using AES-256-ECB and return the plaintext as a UTF-8 string.

        The decrypted data is unpadded by removing the PKCS padding indicated by the last byte.

        :param input_b64: Base64-encoded string containing the ciphertext.
        :return: Decrypted plaintext as a UTF-8 string.
        """
        input_bytes = base64.b64decode(input_b64)
        decrypted = self.aes_ctx.decrypt(input_bytes)
        pad_length = decrypted[-1]
        return decrypted[:-pad_length].decode()


def get_encrypted_config(module: ModuleDefMD) -> dict:
    """
    Extract encrypted configuration (field name and value) from the Settings class.

    This function searches for the .cctor method in the Settings class
    and collects field assignments (Stsfld) preceded by string loads (Ldstr) or integer loads
    (ldc.i4.[0-9] or other ldc opcodes) to capture both string and integer configuration values.

    :param module: The .NET module to analyze.
    :return: A dictionary mapping field names to their encrypted string or integer values.
    """
    settings_type = reversing.Dnlib.find_type_by_name(module, "Settings")
    if not settings_type:
        raise RuntimeError("Failed to find Settings class")

    cctor_method = reversing.Dnlib.find_methods_by_name(module, ".cctor", settings_type)

    if len(cctor_method) == 0:
        raise RuntimeError("Failed to find .cctor method in Client.Settings class")

    encrypted_config = {}
    prev_opcode = None
    prev_operand = None
    ldc_no_operand = {f"ldc.i4.{i}" for i in range(10)}  # Set of ldc.i4.[0-9] opcodes
    instructions = reversing.Dnlib.get_instructions_of_method(cctor_method[0])
    for idx, (opcode, operand) in instructions.items():
        if prev_opcode and opcode == OpCodes.Stsfld:
            if prev_opcode == OpCodes.Ldstr:
                encrypted_config[operand.Name.String] = prev_operand
            elif prev_opcode.Name.startswith("ldc"):
                if prev_opcode.Name in ldc_no_operand:
                    value = int(prev_opcode.Name[-1])
                else:
                    value = operand
                encrypted_config[operand.Name.String] = value
        prev_opcode = opcode
        prev_operand = operand

    return encrypted_config


def decrypt_configuration(encrypted_config: dict, aes_ctx: Aes) -> dict:
    """
    Decrypt an encrypted configuration dictionary using the provided AES context.

    This function attempts to decrypt each string field value in the encrypted configuration.
    Non-string (e.g., integer) values or failed decryptions are retained as-is or set to an empty string.

    :param encrypted_config: Dictionary with field names and encrypted values.
    :param aes_ctx: AES context for decryption.
    :return: Dictionary with field names and decrypted or original values.
    """
    decrypted_config = {}
    for field, value in encrypted_config.items():
        try:
            decrypted_config[field] = aes_ctx.decrypt(value)
        except Exception as e:
            decrypted_config[field] = "" if not value else value

    return decrypted_config


def extract_configuration(binary: bytes) -> Configuration:
    """
    Exctracts the configuration from a XWORM sample, returning a Configuration object.

    :param binary: The .NET binary as bytes.
    :return: A Configuration object containing decrypted configuration.
    """
    module = reversing.Dnlib.load(binary)
    encrypted_config = get_encrypted_config(module)
    aes_ctx = Aes(encrypted_config["Mutex"])
    decrypted_config = decrypt_configuration(encrypted_config, aes_ctx)

    return Configuration(decrypted_config)
