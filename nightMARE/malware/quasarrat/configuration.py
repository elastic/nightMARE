# coding: utf-8

import base64
import json
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Cipher import AES
from Crypto.Hash import SHA1
from Crypto.Util.Padding import unpad

from nightMARE.analysis import reversing

from dnlib.DotNet import ModuleDefMD, MethodDef, TypeDef  # type: ignore
from dnlib.DotNet.Emit import OpCodes  # type: ignore


CONFIG_DECRYPTION_METHOD_PATTERN = [
    "ldsfld",
    "newobj",
    "dup",
    "ldsfld",
    "callvirt",
    "stsfld",
    "dup",
    "ldsfld",
    "callvirt",
    "stsfld",
    "dup",
]


class Configuration(object):

    def __init__(self, config: dict):
        """
        Initialize the Configuration object with a dictionary of decrypted configuration strings.

        :param config: A dictionary of field name and decrypted value pairs
        """
        config_list = list(config.values())
        self.version = config_list[0]
        self.hosts: list[str] = config_list[1].split(";") if config_list[1] else []
        self.reconnect_delay = config_list[2]
        self.special_folder = config_list[3]
        self.subdirectory = config_list[4]
        self.install_name = config_list[5]
        self.install = config_list[6]
        self.startup = config_list[7]
        self.mutex = config_list[8]
        self.startup_key = config_list[9]
        self.hide_file = config_list[10]
        self.enable_logger = config_list[11]
        self.encryption_key = config_list[12]
        self.tag = config_list[13]
        self.log_directory_name = config_list[14]
        self.server_signature = config_list[15]
        self.server_certificate = config_list[16]
        self.hide_log_directory = config_list[17]
        self.hide_install_subdirectory = config_list[18]
        self.install_path = config_list[19]
        self.logs_path = config_list[20]
        self.unattended_mode = config_list[21]

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded configuration fields.
        """
        return json.dumps(
            {
                "version": self.version,
                "hosts": self.hosts,
                "reconnect_delay": self.reconnect_delay,
                "special_folder": self.special_folder,
                "subdirectory": self.subdirectory,
                "install_name": self.install_name,
                "install": self.install,
                "startup": self.startup,
                "mutex": self.mutex,
                "startup_key": self.startup_key,
                "hide_file": self.hide_file,
                "enable_logger": self.enable_logger,
                "encryption_key": self.encryption_key,
                "tag": self.tag,
                "log_directory_name": self.log_directory_name,
                "server_signature": self.server_signature,
                "server_certificate": self.server_certificate,
                "hide_log_directory": self.hide_log_directory,
                "hide_install_subdirectory": self.hide_install_subdirectory,
                "install_path": self.install_path,
                "logs_path": self.logs_path,
                "unattended_mode": self.unattended_mode,
            },
            indent=4,
        )


class Aes:
    def __init__(self, master_key: bytes | str, salt: bytes | str):
        """
        Initialize an AES context with a key derived from a master key and salt using PBKDF2.

        :param master_key: The master key for key derivation.
        :param salt: The salt for key derivation.
        """
        derived = PBKDF2(
            master_key, salt, dkLen=32 + 64, count=50000, hmac_hash_module=SHA1
        )
        self.aes_key = derived[:32]

    def decrypt(self, input_b64: str) -> str:
        """
        Decrypt a base64-encoded string using AES-256-CBC and return the plaintext as a UTF-8 string.

        :param input_b64: Base64-encoded string containing HMAC, IV, and ciphertext.
        :return: Decrypted plaintext as a UTF-8 string.
        """
        input_bytes = base64.b64decode(input_b64)
        decrypted_bytes = self._decrypt_bytes(input_bytes)
        return decrypted_bytes.decode("utf-8")

    def _decrypt_bytes(self, input: bytes) -> bytes:
        """
        Decrypt raw bytes containing HMAC, IV, and ciphertext using AES-256-CBC.

        :param input: Bytes containing HMAC (32 bytes), IV (16 bytes), and ciphertext.
        :return: Decrypted plaintext bytes after removing PKCS7 padding.
        """
        if len(input) < 48:
            raise ValueError("AES: Input too short")

        iv = input[32:48]
        ciphertext = input[48:]

        cipher = AES.new(self.aes_key, AES.MODE_CBC, iv=iv)
        padded_data = cipher.decrypt(ciphertext)

        try:
            return unpad(padded_data, AES.block_size, style="pkcs7")
        except ValueError as e:
            raise ValueError("AES: Invalid padding: %s" % e)


def find_config_decryption_init_pattern(module: ModuleDefMD) -> tuple[MethodDef, int]:
    """
    Find the method containing the configuration decryption initialization
    by matching an opcode pattern.

    :param module: The .NET module to analyze.
    :return: A tuple of (MethodDef, instruction offset) for the matched method.
    """
    return reversing.Dnlib.find_opcode_pattern(
        module, CONFIG_DECRYPTION_METHOD_PATTERN, max_matches=1
    )[0]


def find_aes_class_and_key_field_name(
    matched_method_and_instr_offset: tuple[MethodDef, int],
) -> tuple[TypeDef, str]:
    """
    Extract the AES class and key field name from the matched configuration decryption method.

    This function analyzes the instructions of the matched method starting from the given offset
    to identify the static field (ldsfld) containing the variable/field name for the AES key and the subsequent newobj
    instruction to determine the AES class.

    :param matched_method_and_instr_offset: A tuple of (MethodDef, instruction offset) from pattern matching.
    :return: A tuple of (TypeDef for AES class, AES key field name as string).
    """
    instructions = reversing.Dnlib.get_instructions_of_method(
        matched_method_and_instr_offset[0]
    )
    pattern_matched_idx = matched_method_and_instr_offset[1]
    iterator = iter(instructions.items())
    for idx, (opcode, operand) in iterator:
        if idx < pattern_matched_idx:
            continue
        if opcode.Name == "ldsfld" and operand is not None:
            aes_key_field_name = operand.Name.String
        else:
            raise RuntimeError("Failed to retrieve AES key field name")

        try:
            next_idx, (next_opcode, next_operand) = next(iterator)
        except StopIteration:
            raise RuntimeError(
                "No instruction follows ldsfld to retrieve AES class name"
            )

        if next_opcode.Name == "newobj" and next_operand is not None:
            malware_aes_class = next_operand.DeclaringType
            return malware_aes_class, aes_key_field_name

    raise RuntimeError("Failed to retrieve AES class name and/or AES key field name")


def get_encrypted_config(
    module: ModuleDefMD, matched_method_and_instr_offset: tuple[MethodDef, int]
) -> dict:
    """
    Extract encrypted configuration (field name and value) from the configuration decryption class.

    This function retrieves the .cctor method of the class containing the matched decryption method
    and collects field assignments (Stsfld) preceded by string loads (Ldstr) or integer loads
    (ldc.i4.[0-9] or other ldc opcodes) to capture both string and integer configuration values.

    :param module: The .NET module to analyze.
    :param matched_method_and_instr_offset: A tuple of (MethodDef, instruction offset) from pattern matching.
    :return: A dictionary mapping extracted field names to their encrypted string or integer values.
    """
    config_decryption_class = matched_method_and_instr_offset[0].DeclaringType

    cctor_method = reversing.Dnlib.find_methods_by_name(
        module, ".cctor", config_decryption_class
    )[0]
    instructions = reversing.Dnlib.get_instructions_of_method(cctor_method)

    encrypted_config = {}
    prev_opcode = None
    prev_operand = None
    ldc_no_operand = {f"ldc.i4.{i}" for i in range(10)}  # Set of ldc.i4.[0-9] opcodes
    for idx, (opcode, operand) in instructions.items():
        if prev_opcode and opcode == OpCodes.Stsfld:
            if prev_opcode == OpCodes.Ldstr:
                encrypted_config[operand.Name.String] = prev_operand
            elif prev_opcode.Name.startswith("ldc"):
                if prev_opcode.Name in ldc_no_operand:
                    value = int(prev_opcode.Name[-1])
                else:
                    value = prev_operand
                encrypted_config[operand.Name.String] = value
        prev_opcode = opcode
        prev_operand = operand

    return encrypted_config


def get_salt(module: ModuleDefMD, malware_aes_class: TypeDef) -> bytes | str:
    """
    Retrieve the AES salt (byte array or string) from the specified AES class.

    This function searches for the .cctor method in the provided AES class and extracts
    the salt from either an Ldtoken (byte array) or Ldstr (string) instruction.

    :param module: The .NET module to analyze.
    :param malware_aes_class: The TypeDef of the AES class.
    :return: The salt.
    """
    cctor_method = reversing.Dnlib.find_methods_by_name(
        module, ".cctor", malware_aes_class
    )[0]

    if not cctor_method:
        raise RuntimeError("Failed to find .cctor method in Aes class")

    salt_bytearray = None
    instructions = reversing.Dnlib.get_instructions_of_method(cctor_method)
    for idx, (opcode, operand) in instructions.items():
        if opcode == OpCodes.Ldtoken:
            salt_bytearray = operand.InitialValue
            return bytes(salt_bytearray)
        elif opcode == OpCodes.Ldstr:
            salt = operand
            return salt

    raise RuntimeError("Failed to find salt in Aes .cctor")


def decrypt_configuration(encrypted_config: dict, aes_ctx: Aes) -> dict:
    """
    Decrypt an encrypted configuration dictionary using the provided AES context.

    This function attempts to decrypt each string field value in the encrypted configuration.
    Non-string values (e.g., integers) are retained as-is, and failed decryptions retain the
    original string value.

    :param encrypted_config: Dictionary with field names and encrypted values.
    :param aes_ctx: AES context for decryption.
    """
    decrypted_config = {}
    for field, value in encrypted_config.items():
        if isinstance(value, str):
            try:
                decrypted_config[field] = aes_ctx.decrypt(value)
            except Exception:
                decrypted_config[field] = value
        else:
            decrypted_config[field] = value

    return decrypted_config


def extract_configuration(binary: bytes):
    """
    Extracts the configuration from a QuasarRAT sample, returning a Configuration object.

    :param binary: The .NET binary as bytes.
    :return: A Configuration object containing decrypted configuration.
    """
    module = reversing.Dnlib.load(binary)
    matched_method_and_instr_offset = find_config_decryption_init_pattern(module)
    malware_aes_class, aes_key_field_name = find_aes_class_and_key_field_name(
        matched_method_and_instr_offset
    )
    encrypted_config = get_encrypted_config(module, matched_method_and_instr_offset)
    salt = get_salt(module, malware_aes_class)
    aes_ctx = Aes(encrypted_config[aes_key_field_name], salt)
    decrypted_config = decrypt_configuration(encrypted_config, aes_ctx)

    return Configuration(decrypted_config)
