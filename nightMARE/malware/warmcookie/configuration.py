# coding: utf-8

import ctypes
import dataclasses
import json

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing
from nightMARE.core import cast
from nightMARE.core import regex


PORT_VALUES = (80, 443)

STRING_DECRYPT_PATTERNS = [
    "48894C24??4881EC68010000488B05????????4833C448898424????????48C74424",
    "554881ec40010000488dac248000000048898dd0000000",
    "4154555756534881ec300100004889cf8b318b41048984242c010000",
    "48895c241048896c24184889742420574881ec50010000488b05b2ba01004833c4",
    "48895c241048896c24184889742420574881ec50010000488b0522bc01004833c4",
    "415541545756534881EC????????8B318B41??4889CB",
    "48895C24??48896C24??48897424??57",
    "415541545756534881ec300100008b318b41044889cb488d4e09",
]

SEND_C2_FUNCTION_PATTERNS = [
    "55534881ec18010000488dac248000000048898db0000000488995b80000004489c044898dc8000000668985c0",
    "44894c2420664489442418488954241048894c24084881ec1801000048c74424780000000048c7842",
    "4c894c24204c89442418488954241048894c24084881ec98010000488b05ce0402004833c44889842480010000",
    "48895C24??48896C24??48897424??5741544155415641574883EC??33ED418BF9",
    "48895c240848896c241048897424185741544155415641574883ec60",
    "4157415641554154555756534881EC????????4889CD4C89C1",
    "4157415641554154555756534883EC584889CB4889D54589C44489CE",
    "4157415641554154555756534883ec5848833d68d0010000488bb424c8000000",
    "4157415641554154555756534883EC??48833D??????????488B9C24????????",
    "4157415641554154555756534883ec58",
]


@dataclasses.dataclass
class Configuration(object):
    """
    Represents a configuration object for WarmCookie configuration
    """

    c2: list[bytes]
    campaign: list[bytes]
    rc4_key: bytes
    mutex: list[bytes]


class EncryptedStringDescriptor(ctypes.Structure):
    _pack_ = 1
    _fields_ = [
        ("length", ctypes.c_uint32),
        ("rc4_key", ctypes.c_uint32),
    ]


@dataclasses.dataclass
class EncryptedString(object):
    """
    Represents an encrypted string found in WarmCookie binary.

    :param address: The memory address where the encrypted string's descriptor is located.
    :param rc4_key: The RC4 key used for decryption.
    :param data: The encrypted data of the string.
    :param decryption_function_call_address: The address in the binary where the decryption function for this string is called.
    """

    address: int
    rc4_key: int
    data: bytes
    decryption_function_call_address: int


def decrypt_strings(encrypted_strings: list[EncryptedString]) -> list[bytes]:
    """
    Decrypts a list of encrypted strings using the RC4 key from each descriptor.
    """

    results = []
    for encrypted_string in encrypted_strings:
        cipher = ARC4.new(encrypted_string.rc4_key.to_bytes(4, "little"))
        data = cipher.decrypt(encrypted_string.data)
        results.append(data)

    return results


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extracts the configuration from the WarmCookie binary.

    This function retrieves encrypted strings from the binary, identifies the RC4 key
    from each descriptor, decrypts the strings, and then extracts important information
    from the configuration such as campaign data, C2 URLs, and mutexes. The configuration
    is returned as a `Configuration` object containing this information.

    :param binary: The raw binary data containing the configuration.
    :return: A Configuration object containing the extracted configuration information.
    :raises RuntimeError: If no strings are found for decryption.
    """

    if not (encrypted_strings := get_encrypted_strings(binary)):
        raise RuntimeError("No encrypted string found")

    return parse_configuration(decrypt_strings(encrypted_strings), get_port(binary))


def is_port_near_c2(binary: bytes, port_cand_addr: int, c2_list: list[int]) -> bool:
    """
    Check if the given port candidate is near send c2 function

    :param port_candidate: The port number to check.
    :param c2_list: A list of call sites to send c2
    :return: True if the port candidate is close to any port in the C2 list, False otherwise.
    """
    rz = reversing.Rizin.load(binary)

    for c2_call_sites in c2_list:
        ea = c2_call_sites
        for _ in range(20):
            instruction = rz.disassemble_previous_instruction(ea)
            ea = instruction["addr"]

            if instruction["mnemonic"] in ("mov", "movzx"):
                target_addr = instruction.get("ptr")
                if target_addr is None:
                    continue

                if port_cand_addr == target_addr:
                    return True

    return False


def get_port(binary: bytes) -> int | None:
    """
    Search for default port values in .data section for WarmCookie

    :param binary: The raw binary data containing the port information.
    :return: The extracted port value as bytes, or None if not found.
    """

    rz = reversing.Rizin.load(binary)
    sections = json.loads(rz.rizin.cmd("iSj"))
    data_section = next((s for s in sections if s.get("name") == ".data"), None)

    send_c2_calls = get_send_c2_function_call_addresses(binary)

    if not data_section:
        raise RuntimeError("No .data section found")

    start = data_section["vaddr"]
    end = start + data_section["vsize"]

    for addr in range(start, end, 4):
        port_bytes = rz.get_data(addr, 4)
        port = cast.u32(port_bytes)

        if port in PORT_VALUES and is_port_near_c2(binary, addr, send_c2_calls):
            return port

    return None


def parse_rc4_key(decrypted_str: bytes) -> bytes | None:
    """
    Find the RC4 key used to encrypt network traffic from the list of decrypted strings.

    :param decrypted_strings: A list of decrypted strings.
    :raises RuntimeError: If no RC4 key is found.
    :return: The RC4 key as bytes
    """

    if 8 <= len(decrypted_str) <= 32 and regex.get_regex(
        regex.RegexOptions.HEX_STRING_REGEX, True
    ).match(decrypted_str):
        return decrypted_str.rstrip(b"\x00")

    return None


def find_rc4_key_index(decrypted_strings: list[bytes]) -> int | None:
    """
    Finds the index location of the RC4 key in the decrypted strings list.
    Returns the index or None if not found.

    :param decrypted_strings: A list of decrypted strings.
    :return: The index location of the RC4 key or None if not found.
    """

    for i, decrypted_string in enumerate(decrypted_strings):
        data = decrypted_string.data
        if 8 <= len(data) <= 32 and regex.get_regex(
            regex.RegexOptions.HEX_STRING_REGEX, True
        ).match(data):
            return i

    return None


def parse_mutexes(decrypted_strings: bytes) -> list[bytes]:
    """
    Retrieves UUID strings from decrypted strings (likely mutex names).

    :param decrypted_strings: A list of DecryptedString objects
    :return: A list of UUID strings found in the decrypted strings
    """

    results = []
    for m in regex.get_regex(regex.RegexOptions.GUID_REGEX, True).finditer(
        decrypted_strings
    ):
        results.append(m.group(0))

    return sorted(list(set(results)))


def get_encrypted_strings(binary: bytes) -> list[EncryptedString]:
    """
    Retrieve the addresses and data of encrypted strings by analyzing the binary.

    :param binary: The binary data to analyze.
    :raise RuntimeError: If no encrypted strings are found.
    :return: A list of EncryptedString objects found in the binary.
    """

    rz = reversing.Rizin.load(binary)

    results = []
    string_decrypt_calls = get_string_decryption_call_addresses(binary)
    for call_address in string_decrypt_calls:
        ea = call_address
        encrypted_string_descriptor_addr = None
        for _ in range(10):
            instruction = rz.disassemble_previous_instruction(ea)
            ea = instruction["addr"]

            operands = instruction["opex"]["operands"]
            if (
                len(operands)
                and "reg" == operands[0]["type"]
                and "rcx" == operands[0]["value"]
                and (tmp_addr := instruction.get("ptr"))
            ):
                encrypted_string_descriptor_addr = tmp_addr
                break

        else:
            continue

        desc_data = rz.get_data(
            encrypted_string_descriptor_addr,
            ctypes.sizeof(EncryptedStringDescriptor),
        )

        if not desc_data or len(desc_data) < ctypes.sizeof(EncryptedStringDescriptor):
            continue

        encrypted_string_descriptor = EncryptedStringDescriptor.from_buffer_copy(
            desc_data
        )

        if (
            encrypted_string_descriptor.length > len(binary)
            or encrypted_string_descriptor.length > 0x10000
            or encrypted_string_descriptor.length == 0xFFFFFFFF
            or encrypted_string_descriptor.length == 0
        ):
            continue

        encrypted_string_address = encrypted_string_descriptor_addr + ctypes.sizeof(
            EncryptedStringDescriptor
        )

        string_data = rz.get_data(
            encrypted_string_address,
            encrypted_string_descriptor.length,
        )

        if not string_data or len(string_data) < encrypted_string_descriptor.length:
            continue

        results.append(
            EncryptedString(
                encrypted_string_address,
                encrypted_string_descriptor.rc4_key,
                string_data,
                call_address,
            )
        )

    return results


def get_string_decryption_call_addresses(binary: bytes) -> list[int]:
    """
    Locate all calls to string decryption function in WarmCookie

    :param binary: The binary data to analyze.
    :raise RuntimeError: If no string decryption calls are found.
    :return: A list of addresses where string decryption calls are made.
    """

    rz = reversing.Rizin.load(binary)

    addresses = []
    for pattern in STRING_DECRYPT_PATTERNS:
        for address in (
            x["address"]
            for x in rz.find_pattern(pattern, reversing.Rizin.PatternType.HEX_PATTERN)
        ):
            addresses += rz.get_xrefs_to(address)

    return sorted(list(set(addresses)))


def get_send_c2_function_call_addresses(binary: bytes) -> list[int]:
    """
    Locate all calls to the send C2 function in WarmCookie

    :param binary: The binary data to analyze.
    :raise RuntimeError: If no send C2 function calls are found.
    :return: A list of addresses where send C2 function calls are made.
    """

    rz = reversing.Rizin.load(binary)

    addr_list = []
    for pattern in SEND_C2_FUNCTION_PATTERNS:
        pattern_results = rz.find_pattern(
            pattern, reversing.Rizin.PatternType.HEX_PATTERN
        )

        for result in pattern_results:
            pattern_addr = result.get("address")

            if pattern_addr:
                xrefs = rz.get_xrefs_to(pattern_addr)
                addr_list.extend(xrefs)

            else:
                print(f"Could not extract address from result: {result}")

    if not addr_list:
        raise RuntimeError("No send C2 function calls found for any pattern")

    return sorted(list(set(addr_list)))


def parse_configuration(
    decrypted_strings: list[bytes], port: int | None
) -> Configuration:
    """
    Parses the port and configuration from a list of decrypted strings.

    :param port: The port number used for C2 communication.
    :param decrypted_strings: A list of decrypted strings.
    :raises RuntimeError: If essential configuration elements are missing.
    :return: A Configuration object containing the parsed configuration information.
    """

    c2_list = []
    mutexes = []
    rc4_key: bytes | None = None
    campaign: bytes | None = None
    found_rc4_key_index = None
    for i, decrypted_string in enumerate(decrypted_strings):
        try:
            decrypted_string = decrypted_string.replace(b"\x00", b"")
        except:
            decrypted_string = decrypted_string

        if tmp := parse_c2(decrypted_string):
            c2_list.append(tmp)

        elif tmp := parse_mutexes(decrypted_string):
            mutexes += tmp

        elif not rc4_key and (tmp := parse_rc4_key(decrypted_string)):
            rc4_key = tmp
            found_rc4_key_index = i

    if found_rc4_key_index:
        try:
            candidate = (
                decrypted_strings[found_rc4_key_index + 1]
                .decode("utf-16")
                .encode("utf-8")
            )

        except UnicodeDecodeError:
            candidate = decrypted_strings[found_rc4_key_index + 1]

    campaign = candidate if len(candidate) < 20 else None
    mutexes = sorted(list(set(mutexes)))

    if not all([c2_list, rc4_key]):
        raise RuntimeError("Failed to parse configuration")

    if port:
        c2_list = [
            b"http" + (b"s" if port == 443 else b"") + b"://" + x for x in c2_list
        ]

    return Configuration(c2_list, campaign, rc4_key, mutexes)


def parse_c2(decrypted_string: bytes) -> bytes | None:
    """
    Retrieves the C2 URLs and IP addresses from a list of decrypted strings.

    :param decrypted_strings: A list of decrypted strings.
    :raises RuntimeError: If no C2 addresses are found.
    :return: A list of C2 URLs and IP addresses.
    """

    for x in [
        regex.RegexOptions.IP_PORT_REGEX,
        regex.RegexOptions.IP_REGEX,
        regex.RegexOptions.URL_REGEX,
        regex.RegexOptions.DOMAIN_REGEX,
    ]:
        if m := regex.get_regex(x, True).search(decrypted_string):
            value = m.group(0).rstrip(b"\x00")
            if not value.lower().endswith((b".dll", b".exe")):
                return value

    return None
