# coding: utf-8

import json
import re

from Crypto.Cipher import AES
from Crypto.Util import Counter
from fnvhash import fnv1a_32

from nightMARE.core import cast
from nightMARE.analysis import reversing
from nightMARE.core import utils

URI_TLD_REGEX = re.compile(rb"https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/[^\s]*)?")
DECRYPTION_FUNCTION_PATTERN = "488954241048894c240856574881ec68010000"
CAMPAIGN_FUNCTION_PATTERN = "83E00833C085C075"
LATRODECTUS_VERSION_PATTERNS = [
    "C74424????000000C74424????000000C74424????0000008B",
    "C74424??????????48C74424??????????C74424??????????8B",
]
VERSION_DISASSEMBLY_RANGE = 0x3
KEY_SCAN_RANGE_IN_DECRYPTION_FUNCTION = 0x40
ENCRYPTED_STRING_LENGTH = 0x2
AES_KEY_SIZE = 0x20
RC4_KEY_SIZE = 0x40
IV_LENGTH = 0x10
LEA_PREV_INSTRUCTION_INPUT = 0x7


class Configuration(object):
    """
    Represents a configuration object for Latrodectus malware settings decrypted from AES-encrypted strings.
    """

    def __init__(self, config: list):
        """
        Initialize the Configuration object with a list of decrypted configuration values.

        :param config: A list of byte strings representing the raw configuration data.
        """

        self.c2_list: list[bytes] = config[0]
        self.version: bytes = config[1]
        self.campaign_string: bytes = config[2]
        self.campaign_id: int = config[3]
        self.rc4_key: bytes = config[4]

    def __repr__(self) -> str:
        """
        Provide a JSON string representation of the configuration.

        :return: A JSON-formatted string with decoded configuration fields.
        """

        return json.dumps(
            {
                "c2": [x.decode("utf-8") for x in self.c2_list],
                "version": self.version.decode("utf-8"),
                "campaign_name": self.campaign_string.decode("utf-8"),
                "campaign_id": self.campaign_id,
                "rc4_key": self.rc4_key.decode("utf-8"),
            }
        )


def get_aes_key(binary: bytes) -> bytes:
    """
    Retrieve the AES key used for decryption from Latrodectus binary.

    :param binary: The raw binary data containing the AES key.
    :raise RuntimeError: If the AES key cannot be extracted or is not 32 bytes long.
    :return: The AES key as a byte sequence.
    """

    rz = reversing.Rizin.load(binary)

    pattern_offset = rz.find_first_pattern(
        [DECRYPTION_FUNCTION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
    )
    disassembled = rz.disassemble(pattern_offset, KEY_SCAN_RANGE_IN_DECRYPTION_FUNCTION)
    key = []
    for instruction in disassembled:
        if (
            instruction["mnemonic"] == "mov"
            and "[rsp" in instruction["opcode"]
            and instruction["opex"]["operands"][1]["type"] == "imm"
        ):
            key.append(instruction["opex"]["operands"][1]["value"])

    if len(key) != AES_KEY_SIZE:
        raise RuntimeError("Failed to extract a valid 32-byte AES key")
    return bytes(key)


def get_campaign_address(binary: bytes) -> int:
    """
    Locate the campaign function address in Latrodectus

    :param binary: The raw binary data to analyze.
    :return: The address of the campaign function.
    :raise RuntimeError: If the campaign function pattern cannot be found.
    """

    rz = reversing.Rizin.load(binary)

    pattern_offset = rz.find_first_pattern(
        [CAMPAIGN_FUNCTION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
    )

    if pattern_offset is None:
        raise RuntimeError("Failed to find campaign function pattern in binary")
    return pattern_offset


def get_str_decrypt_calls(binary: bytes) -> list[int]:
    """
    Locate all calls to string decryption function in Latrodectus

    :param binary: The raw binary data to analyze.
    :return: The list of all addresses to string decryption function calls.
    :raise RuntimeError: If no xrefs to string decryption function cannot be found.
    """

    rz = reversing.Rizin.load(binary)

    pattern_offset = rz.find_first_pattern(
        [DECRYPTION_FUNCTION_PATTERN], reversing.Rizin.PatternType.HEX_PATTERN
    )
    xrefs = rz.get_xrefs_to(pattern_offset)
    if not xrefs:
        raise RuntimeError("Failed to find any xrefs to decryption function")
    results = []
    for xref in xrefs:
        results.append(xref)
    return results


def get_encrypted_string_addrs(binary: bytes, addresses: list[int]) -> list[dict]:
    """
    Retrieve the addresses of encrypted strings by reading previous instructions.

    :param binary: The raw binary data to analyze.
    :param addresses: A list of addresses where the string decryption function is called.
    :raise RuntimeError: If the previous instruction or pointer cannot be found for any address.
    :return: A list of dictionaries containing the xref address and the pointer to the encrypted string.
    """

    rz = reversing.Rizin.load(binary)

    results = []
    for addr in addresses:
        prev_instruction = rz.get_previous_instructions_via_bytes(
            addr, LEA_PREV_INSTRUCTION_INPUT
        )
        if not prev_instruction or "ptr" not in prev_instruction[0]:
            raise RuntimeError(
                f"Failed to find previous instruction or pointer for address {hex(addr)}"
            )
        result = {"xref": addr, "ptr": prev_instruction[0]["ptr"]}
        results.append(result)
    return results


def decrypt_strings(binary: bytes, key: bytes, addresses: list[dict]) -> list[dict]:
    """
    Decrypt strings using AES CTR mode with the provided key and addresses.

    :param binary: The raw binary data containing the encrypted strings.
    :param key: The AES key used for decryption.
    :param addresses: A list of dictionaries containing the xref address and pointer to the encrypted string.
    :raise RuntimeError: If the decryption fails or if the key is not 32 bytes long.
    :return: A list of dictionaries containing the decrypted strings, their addresses, and xref addresses.
    """

    rz = reversing.Rizin.load(binary)

    results = []
    for addr_info in addresses:
        str_len_bytes = rz.get_data(addr_info["ptr"], ENCRYPTED_STRING_LENGTH)
        if not str_len_bytes or len(str_len_bytes) != ENCRYPTED_STRING_LENGTH:
            raise RuntimeError(
                f"Failed to read string length at {hex(addr_info['ptr'])}"
            )

        str_len = cast.u16(str_len_bytes)
        iv = rz.get_data(addr_info["ptr"] + ENCRYPTED_STRING_LENGTH, IV_LENGTH)
        if not iv or len(iv) != IV_LENGTH:
            raise RuntimeError(
                f"Failed to read IV at {hex(addr_info['ptr'] + ENCRYPTED_STRING_LENGTH)}"
            )

        encrypted_string = rz.get_data(
            addr_info["ptr"] + ENCRYPTED_STRING_LENGTH + IV_LENGTH, str_len
        )
        if not encrypted_string or len(encrypted_string) != str_len:
            raise RuntimeError(
                f"Failed to read encrypted string at {hex(addr_info['ptr'] + ENCRYPTED_STRING_LENGTH + IV_LENGTH)}"
            )

        try:
            iv_int = int.from_bytes(iv, byteorder="big")
            ctr = Counter.new(128, initial_value=iv_int)
            aes = AES.new(key, AES.MODE_CTR, counter=ctr)
        except Exception as e:
            raise RuntimeError(f"Decryption failed at {hex(addr_info['ptr'])}: {e}")

        result = {
            "string": aes.decrypt(encrypted_string),
            "addr": addr_info["ptr"],
            "xref": addr_info["xref"],
        }
        results.append(result)
    return results


def find_campaign_string(
    campaign_address: int, string_decrypt_addrs: list[int], configuration: list[dict]
) -> bytes | None:
    """
    Look back from campaign_address to find the closest string decryption function used with campaign.

    :param campaign_address: The address to look back from.
    :param string_decrypt_addrs: List of string decryption addresses.
    :param configuration: A list of dictionaries containing decrypted string data, xrefs, and string addresses.
    :raises RuntimeError: If no campaign string is found.
    :return: The closest string or None if not found.
    """

    xrefs_set = set(string_decrypt_addrs)
    for backwards_addr in range(campaign_address, max(campaign_address - 256, 0), -1):
        if backwards_addr in xrefs_set:
            for entry in configuration:
                if entry["xref"] == backwards_addr:
                    return entry["string"]
    raise RuntimeError("Failed to find campaign string")


def find_rc4_key(configuration: list[dict]) -> bytes:
    """
    Find the RC4 key from the configuration function calls.

    :param configuration: A list of dictionaries containing decrypted string data and address information.
    :raises RuntimeError: If the RC4 key is not found or is not of the expected size.
    :return: The RC4 key as bytes.
    """

    for entry in configuration:
        if "string" in entry:
            s = entry["string"]
            if len(s) == RC4_KEY_SIZE + 1 and s[-1] == 0:
                return s[:-1]  # Strip null terminator
            elif len(s) == RC4_KEY_SIZE:
                return s
    raise RuntimeError("RC4 Key not found")


def extract_version(binary: bytes, pattern_offset: int) -> bytes:
    """
    Extract the version number from the list of values.

    :param binary: The raw binary data to analyze.
    :param pattern_offset: The offset in the binary where the version pattern was found.
    :raises RuntimeError: If the disassembly fails or if there are not enough immediate values to extract the version.
    :return: The version number as a string in the format "major.minor.patch".
    """

    rz = reversing.Rizin.load(binary)

    instructions = rz.disassemble(pattern_offset, VERSION_DISASSEMBLY_RANGE)
    if not instructions:
        raise RuntimeError("Failed to disassemble instructions for version extraction")

    immediates = []
    for instr in instructions:
        if (
            "opex" in instr
            and "operands" in instr["opex"]
            and len(instr["opex"]["operands"]) > 1
            and instr["opex"]["operands"][1]["type"] == "imm"
        ):
            immediates.append(instr["opex"]["operands"][1]["value"])

    if len(immediates) != 3:
        raise RuntimeError("Insufficient data to extract version number")

    major = immediates[2]
    minor = immediates[1]
    patch = immediates[0]
    return f"{major}.{minor}.{patch}".encode("utf-8")


def get_latrodectus_version(binary: bytes) -> bytes:
    """
    Retrieve the version number from the binary using version patterns.

    :param binary: The raw binary data to analyze.
    :raises RuntimeError: If no version pattern matches in the binary.
    :return: The version number as bytes in the format "major.minor.patch".
    """

    rz = reversing.Rizin.load(binary)

    pattern_offset = None
    for pattern in LATRODECTUS_VERSION_PATTERNS:
        try:
            pattern_offset = rz.find_first_pattern(
                [pattern], reversing.Rizin.PatternType.HEX_PATTERN
            )
            if pattern_offset is not None:
                break
        except Exception:
            continue

    if pattern_offset is None:
        raise RuntimeError("No version pattern matched in binary.")
    return extract_version(binary, pattern_offset)


def get_c2(configuration: list[dict]) -> list[bytes]:
    """
    Retrieves the C2 URL from a list of decrypted strings.

    This function searches through the list of decrypted strings to find a URL and its corresponding
    URI path with a valid TLD (top-level domain). The first valid URL found is returned.

    :param configuration: A list of decrypted strings (in bytes), which may contain URLs.
    :raises RuntimeError: If no valid URL is found.
    :return: A list of valid URLs found in the decrypted strings.
    """

    urls = []
    for entry in configuration:
        decrypted_string = entry["string"]

        if utils.is_url(decrypted_string):
            urls.append(decrypted_string)
        elif match := re.search(URI_TLD_REGEX, decrypted_string):
            urls.append(match.group(0))

    if not urls:
        raise RuntimeError("Failed to find any valid URLs")
    return urls


def extract_configuration(binary: bytes) -> Configuration:
    """
    Extracts the configuration from the Latrodectus binary.

    This function retrieves candidate strings from the binary, identies the AES key, decrypts the strings,
    and then extracts important information from the configuration such as campaign data, C2 URLs and version.
    The configuration is returned as a `Configuration` object containing this information.

    :param binary: The raw binary data containing the configuration.
    :return: A Configuration object containing the configuration information.
    """

    str_decrypt_addrs = get_str_decrypt_calls(binary)
    encrypted_string_addresses = get_encrypted_string_addrs(binary, str_decrypt_addrs)
    config = decrypt_strings(binary, get_aes_key(binary), encrypted_string_addresses)

    raw_config = []
    raw_config.append(get_c2(config))
    raw_config.append(get_latrodectus_version(binary))
    raw_config.append(
        find_campaign_string(get_campaign_address(binary), str_decrypt_addrs, config)
    )
    raw_config.append(
        fnv1a_32(
            find_campaign_string(
                get_campaign_address(binary), str_decrypt_addrs, config
            ).rstrip(b"\x00")
        )
    )
    raw_config.append(find_rc4_key(config))
    return Configuration(raw_config)
