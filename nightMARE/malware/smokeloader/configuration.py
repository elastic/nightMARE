# coding: utf-8

import typing

from Crypto.Cipher import ARC4

from nightMARE.analysis import reversing


SMOKELOADER_PATTERN_x64 = "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 41 56 41 57 48 83 EC 40 4C 8B FA 48 8B E9 E8 ?? ?? ?? ?? 48 ?? ?? ?? ?? ?? ?? 48 8B CD"
SMOKELOADER_PATTERN_x86 = (
    "51 53 55 56 57 ?? ?? ?? ?? 8B E9 E8 ?? ?? ?? ?? BA ?? ?? ?? ?? 8B CD E8"
)


RVA_TO_RAW_OFFSET = 0x400 - 0x1000


def get_encrypted_configuration(
    binary: bytes, encrypted_configuration_offset: int
) -> tuple[bytes, bytes]:
    """
    Extracts the encryption key and the encrypted configuration from the binary data.

    :param config_addr: The address where the configuration starts.
    :param data: The binary data containing the configuration.
    :return: A tuple containing the encryption key and the encrypted configuration.
    """
    r2 = reversing.Radare2.load(binary)
    encrypted_configuration_size = r2.get_u8(encrypted_configuration_offset)
    key = r2.get_data(encrypted_configuration_offset + 1, 4)
    encrypted_configuration = r2.get_data(
        encrypted_configuration_offset + 5, encrypted_configuration_size + 1
    )
    return key, encrypted_configuration


def get_configuration(
    binary: bytes, encrypted_configuration_offset: int
) -> dict[str, typing.Any]:
    """
    Decrypts the configuration.

    :param size_rva_encrypted: A list of extracted addresses where the encryption key and encrypted configuration are found.
    :param pe: The PE (Portable Executable) file object.

    :return: The decrypted configuration.
    """
    key, encrypted_configuration = get_encrypted_configuration(
        binary, encrypted_configuration_offset
    )
    return {"c2": ARC4.new(key).decrypt(encrypted_configuration)}


def get_encrypted_configuration_offset_32(
    binary: bytes, config_decryption_function_offset: int
) -> int:
    """
    Disassembles using Capstone to find the addresses where the encryption key
    and the encrypted configuration are located.

    :param data: The binary data to disassemble.
    :param config_decrypt_func_offset: The offset to start disassembling from.
    :param is_64: A boolean indicating whether the binary is 64-bit or not.

    :return: The extracted address where the encryption key and encrypted configuration are found.
    """

    r2 = reversing.Radare2.load(binary)
    r2.set_bits(32)
    ea = r2.get_previous_instruction_offset(config_decryption_function_offset)
    while True:
        instruction = r2.disassemble_next_instruction(ea)
        operands = instruction["opex"]["operands"]

        if (
            len(operands) > 1
            and instruction["mnemonic"] == "mov"
            and operands[0]["type"] == "reg"
            and operands[0]["value"] == "edx"
            and operands[1]["type"] == "imm"
        ):
            return (operands[1]["value"] + RVA_TO_RAW_OFFSET) & 0xFFFF

        elif instruction["type"] in ["jmp", "cjmp", "ret"]:
            raise RuntimeError("Failed to get encryption offset")

        ea = instruction["addr"]


def get_encrypted_configuration_offset_64(
    binary: bytes, config_decryption_function_offset: int
) -> int:
    r2 = reversing.Radare2.load(binary)
    r2.set_bits(64)
    offset = r2.get_previous_instruction_offset(config_decryption_function_offset)
    ea = offset
    while True:
        instruction = r2.disassemble_next_instruction(ea)
        operands = instruction["opex"]["operands"]

        if (
            len(operands) > 1
            and instruction["mnemonic"] == "lea"
            and operands[0]["type"] == "reg"
            and operands[0]["value"] == "rdx"
            and operands[1]["type"] == "mem"
        ):
            return operands[1]["disp"] + instruction["addr"] + instruction["size"]

        elif instruction["type"] in ["jmp", "cjmp", "ret"]:
            raise RuntimeError("Failed to get encryption offset")

        ea = instruction["addr"]


def get_configuration_decryption_function_offset(
    binary: bytes,
) -> tuple[bool, int]:
    r2 = reversing.Radare2.load(binary)
    if x := r2.find_pattern(
        SMOKELOADER_PATTERN_x64, reversing.Radare2.PatternType.HEX_PATTERN
    ):
        return True, x[0]["offset"]
    elif x := r2.find_pattern(
        SMOKELOADER_PATTERN_x86, reversing.Radare2.PatternType.HEX_PATTERN
    ):
        return False, x[0]["offset"]
    else:
        raise RuntimeError("Failed to get config decryption function offset")


def extract_configuration(binary: bytes) -> dict[str, typing.Any]:
    """
    Extracts configuration from SmokeLoader.

    :param data: The binary data to extract information from.

    :return: A dictionary containing the extracted configuration.
    """
    is_x64, configuration_decryption_function_offset = (
        get_configuration_decryption_function_offset(binary)
    )

    return get_configuration(
        binary,
        (
            get_encrypted_configuration_offset_64(
                binary, configuration_decryption_function_offset
            )
            if is_x64
            else get_encrypted_configuration_offset_32(
                binary, configuration_decryption_function_offset
            )
        ),
    )
